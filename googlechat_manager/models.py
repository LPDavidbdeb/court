from django.db import models
from django.db.models import JSONField
from protagonist_manager.models import Protagonist

class ChatParticipant(models.Model):
    """
    Represents a user in the Google Chat history.
    """
    # Google ID from the JSON (e.g., "user/12345")
    original_id = models.CharField(max_length=255, unique=True, help_text="The unique ID from Google export")
    name = models.CharField(max_length=255, blank=True, null=True)
    email = models.EmailField(blank=True, null=True)
    
    # Link to your project's centralized Protagonist system
    protagonist = models.ForeignKey(
        Protagonist, 
        on_delete=models.SET_NULL, 
        null=True, 
        blank=True, 
        related_name='chat_identities',
        help_text="Link this chat user to a real protagonist in your story."
    )

    def __str__(self):
        return self.name or self.email or self.original_id


class ChatThread(models.Model):
    """
    Groups messages that belong to the same thread in Google Chat.
    """
    original_thread_id = models.CharField(max_length=255, unique=True)
    # Space ID if available (e.g. "spaces/AAAA...")
    space_id = models.CharField(max_length=255, blank=True, null=True)
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"Thread {self.original_thread_id}"


class ChatMessage(models.Model):
    """
    The raw atomic unit of the chat.
    """
    thread = models.ForeignKey(ChatThread, on_delete=models.CASCADE, related_name='messages')
    sender = models.ForeignKey(ChatParticipant, on_delete=models.SET_NULL, null=True, related_name='messages')
    
    # The actual timestamp of the message from the export
    timestamp = models.DateTimeField(db_index=True)
    
    # The text content (HTML or Plain)
    text_content = models.TextField(blank=True, null=True)
    
    # Store the full original JSON for this message to ensure no data loss (reactions, attachments, etc)
    raw_data = JSONField(blank=True, null=True)

    # Field to track AI processing status
    is_processed_by_ai = models.BooleanField(default=False)

    class Meta:
        ordering = ['timestamp']

    def __str__(self):
        sender_name = self.sender.name if self.sender else "Unknown"
        return f"[{self.timestamp}] {sender_name}: {self.text_content[:50]}..."


# --- AI Clustering Models ---

class ChatSubject(models.Model):
    """
    Represents a distinct subject/topic identified by Gemini.
    """
    title = models.CharField(max_length=255)
    description = models.TextField(blank=True, help_text="Gemini's summary of this subject.")
    
    # Tags generated by AI
    keywords = JSONField(default=list, blank=True, help_text="List of keywords associated with this subject")
    
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.title


class SubjectGroup(models.Model):
    """
    Links a set of messages to a Subject.
    We use this intermediate model because a conversation about a subject
    might happen in multiple disconnected bursts (e.g., one in Jan, one in March).
    """
    subject = models.ForeignKey(ChatSubject, on_delete=models.CASCADE, related_name='groups')
    
    # The messages included in this specific burst of conversation
    messages = models.ManyToManyField(ChatMessage, related_name='subject_groups')
    
    # Metadata about this specific grouping
    start_date = models.DateTimeField(null=True, blank=True)
    end_date = models.DateTimeField(null=True, blank=True)
    
    reasoning = models.TextField(blank=True, help_text="Why Gemini grouped these messages together.")

    class Meta:
        ordering = ['start_date']

    def save(self, *args, **kwargs):
        # Auto-calculate dates if messages are linked (requires saving first to have ID)
        super().save(*args, **kwargs)
        # Note: You would typically call a method to update start/end_date after adding messages.
